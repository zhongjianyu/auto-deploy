package auto.deploy.security;

import javax.annotation.Resource;
import javax.sql.DataSource;

import org.jasig.cas.client.session.SingleSignOutFilter;
import org.jasig.cas.client.validation.Cas20ServiceTicketValidator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.security.cas.ServiceProperties;
import org.springframework.security.cas.authentication.CasAuthenticationProvider;
import org.springframework.security.cas.web.CasAuthenticationEntryPoint;
import org.springframework.security.cas.web.CasAuthenticationFilter;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.session.SessionRegistry;
import org.springframework.security.web.authentication.logout.LogoutFilter;
import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;
import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;

import auto.deploy.config.CasConfig;
import auto.deploy.websocket.service.WebSocketService;

/**
 * 
 * @描述：security配置(cas单点登录)
 *
 * @作者：zhongjy
 *
 * @时间：2017年5月2日 下午9:43:01
 */
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Resource
	private CustomSuccessHandler customSuccessHandler;
	@Resource
	private CustomFailureHandler customFailureHandler;
	@Resource
	private CustomUserDetailsService customUserDetailsService;
	@Resource
	private CustomPasswordEncoder customPasswordEncoder;
	@Resource
	private CustomAuthenticationDetailsSource customAuthenticationDetailsSource;
	@Resource
	private DataSource dataSource;
	@Resource
	private SessionRegistry sessionRegistry;
	@Resource
	private WebSocketService webSocketService;
	@Resource
	private CasConfig casConfig;

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		//auth.authenticationProvider(getAuthenticationProvider());
		auth.authenticationProvider(casAuthenticationProvider());
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		// 允许访问的页面
		// String[] limitVisitHtml = { "/login.html",
		// "/validateCode/codeImg.html" };
		// 允许访问的资源
		// String[] limitVisitResource = { "/**/*.js", "/**/*.css",
		// "/**/*.woff", "/**/*.woff2", "/**/*.otf", "/**/*.eot", "/**/*.svg",
		// "/**/*.ttf",
		// "/**/*.png", "/**/*.jpg", "/**/*.gif", "/**/*.json" };
		/*
		 * http.authorizeRequests().antMatchers(limitVisitHtml).permitAll()//
		 * 访问匹配的url无需认证 .antMatchers(limitVisitResource).permitAll()// 不拦截静态资源
		 * .anyRequest().authenticated()// 所有资源都需要认证，登陆后访问
		 * .and().formLogin().loginPage("/login.html")// 登录表单
		 * .loginProcessingUrl("/login.do")// 登录请求url
		 * .usernameParameter("loginUserName")// 登录表单账户的name
		 * .passwordParameter("loginUserPwd")// 登录表单密码的name
		 * .successHandler(customSuccessHandler)// 自定义登录成功处理
		 * .failureHandler(customFailureHandler)// 自定义登录失败处理
		 * .authenticationDetailsSource(customAuthenticationDetailsSource)//
		 * 自定义额外表单数据
		 * .and().rememberMe().rememberMeParameter("loginRememberMe")//
		 * 登录表单记住我name
		 * .tokenRepository(persistentTokenRepository()).tokenValiditySeconds(
		 * 86400)// 记住我持久化并设定时间 .and().logout()// (2)---------------.登出表单配置
		 * .logoutSuccessUrl("/login.html")// 退出成功跳转 .logoutUrl("/logout.do")//
		 * 登出请求url .addLogoutHandler(new
		 * CustomSecurityContextLogoutHandler(sessionRegistry()))// 自定义退出处理器
		 * .and().csrf()//
		 * (3)---------------.启用跨站请求伪造(CSRF)保护,如果启用了CSRF，那么在登录或注销页面中必须包括_csrf.
		 * token .and().headers().defaultsDisabled().cacheControl()//
		 * 解决iframe加载问题（x-frame-options） ;
		 */
		// 限制只能单用户登录，如果重复登录，则先登录的用户被强制退出
		// http.sessionManagement().maximumSessions(1).expiredUrl("/login.html").sessionRegistry(sessionRegistry());
		// 限制只能单用户登录，如果重复登录，则提示不能登录(这个方法如果没有进行退出操作直接关掉浏览器，重新登录有问题)
		// http.sessionManagement().maximumSessions(1).maxSessionsPreventsLogin(true).sessionRegistry(sessionRegistry());

		http.authorizeRequests()// 配置安全策略
				// .antMatchers("/","/hello").permitAll()//定义/请求不需要验证
				.anyRequest().authenticated()// 其余的所有请求都需要验证
				.and().logout().permitAll().logoutUrl("/logout.do")// 登出请求url// 定义logout不需要验证
				.and().formLogin().loginProcessingUrl("/login.do");// 使用form表单登录

		http.exceptionHandling().authenticationEntryPoint(casAuthenticationEntryPoint()).and().addFilter(casAuthenticationFilter())
				.addFilterBefore(casLogoutFilter(), LogoutFilter.class).addFilterBefore(singleSignOutFilter(), CasAuthenticationFilter.class);
	}

	/**
	 * 
	 * @描述：session注册器
	 *
	 * @返回：SessionRegistry
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年7月28日 下午10:25:45
	 */
	@Bean
	public SessionRegistry sessionRegistry() {
		return new CustomSessionRegistryImpl();
	}

	/**
	 * 
	 * @描述：自定义权限提供者
	 *
	 * @返回：DaoAuthenticationProvider
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年5月9日 下午9:09:38
	 */
	/*public DaoAuthenticationProvider getAuthenticationProvider() {
		DaoAuthenticationProvider provider = new DaoAuthenticationProvider() {
			@Override
			public Authentication authenticate(Authentication authentication) throws AuthenticationException {
				// 增加对验证码的判断
				CustomWebAuthenticationDetails form = (CustomWebAuthenticationDetails) authentication.getDetails();
				if (StringUtils.isEmpty(form.getLoginValidateCode())) {
					// 判断是否为空
					throw new UsernameNotFoundException("验证码不能为空");
				} else {
					// 判断是否正确
					if (StringUtils.isEmpty(form.getLoginSessionCode())) {
						throw new UsernameNotFoundException("服务器验证码异常");
					} else {
						if (!(form.getLoginSessionCode()).equals(form.getLoginValidateCode())) {
							throw new UsernameNotFoundException("验证码错误");
						}
					}
				}
				return super.authenticate(authentication);
			}

			@Override
			protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)
					throws AuthenticationException {
				super.additionalAuthenticationChecks(userDetails, authentication);
				// 校验通过后，获取第一次登录用户信息,推送强制离线消息
				System.out.println("校验通过。。。");
				List<SessionInformation> infoList2 = sessionRegistry.getAllSessions(userDetails, false);
				if (infoList2.size() > 0) {
					CustomUser customUser = (CustomUser) userDetails;
					WebSocketMsg msg = new WebSocketMsg();
					msg.setCode(1);
					msg.setMessage("重复登录提示");
					CustomWebAuthenticationDetails details = (CustomWebAuthenticationDetails) authentication.getDetails();
					msg.setObject("你的账号[" + authentication.getPrincipal() + "]在[" + details.getRemoteAddress() + "]中登录，本次登录被强制退出");
					webSocketService.pushMessageToUser(msg, customUser.getUsername());
				}

			}

		};
		// 自定义用户登录
		provider.setUserDetailsService(customUserDetailsService);
		// 密码加密器
		provider.setPasswordEncoder(customPasswordEncoder);
		// 是否隐藏用户不存在异常(提示)
		provider.setHideUserNotFoundExceptions(false);
		// 制定本地提示消息文件
		provider.setMessageSource(getMessageSource());
		return provider;
	}*/

	/**
	 * 
	 * @描述：重定义消息文件
	 *
	 * @返回：ReloadableResourceBundleMessageSource
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年5月9日 下午10:32:54
	 */
	public ReloadableResourceBundleMessageSource getMessageSource() {
		ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
		messageSource.setBasename("classpath:security_messages_zh_CN");
		return messageSource;
	}

	/**
	 * 
	 * @描述：自定义remember me持久化
	 *
	 * @返回：PersistentTokenRepository
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年5月10日 下午9:52:25
	 */
	public PersistentTokenRepository persistentTokenRepository() {
		CustomJdbcTokenRepositoryImpl tokenRepositoryImpl = new CustomJdbcTokenRepositoryImpl();
		tokenRepositoryImpl.setDataSource(dataSource);
		return tokenRepositoryImpl;
	}

	/**
	 * remember-me必须指定UserDetailsService
	 */
	/*@Override
	protected UserDetailsService userDetailsService() {
		return customUserDetailsService;
	}*/

	/**
	 * 
	 * @描述：认证入口
	 *
	 * @返回：CasAuthenticationEntryPoint
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午12:32:14
	 */
	@Bean
	public CasAuthenticationEntryPoint casAuthenticationEntryPoint() {
		CasAuthenticationEntryPoint casAuthenticationEntryPoint = new CasAuthenticationEntryPoint();
		casAuthenticationEntryPoint.setLoginUrl(casConfig.getCasLoginUrl());
		casAuthenticationEntryPoint.setServiceProperties(serviceProperties());
		return casAuthenticationEntryPoint;
	}

	/**
	 * 
	 * @描述：设置客户端service的属性:主要设置请求cas服务端后的回调路径,一般为主页地址，不可为登录地址.
	 *
	 * @返回：ServiceProperties
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午12:37:12
	 */
	@Bean
	public ServiceProperties serviceProperties() {
		ServiceProperties serviceProperties = new ServiceProperties();
		// 设置回调的service路径，此为主页路径
		serviceProperties.setService(casConfig.getAppUrl() + casConfig.getAppLoginUrl());
		// 对所有的未拥有ticket的访问均需要验证
		serviceProperties.setAuthenticateAllArtifacts(true);
		return serviceProperties;
	}

	/**
	 * 
	 * @描述：配置ticket校验器
	 *
	 * @返回：Cas20ServiceTicketValidator
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午3:48:40
	 */
	@Bean
	public Cas20ServiceTicketValidator cas20ServiceTicketValidator() {
		// 配置上服务端的校验ticket地址
		return new Cas20ServiceTicketValidator(casConfig.getCasUrl());
	}

	/**
	 * 
	 * @描述：单点注销Filter类，接收cas服务端发出的注销session请求
	 *
	 * @返回：SingleSignOutFilter
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午3:10:26
	 */
	@Bean
	public SingleSignOutFilter singleSignOutFilter() {
		SingleSignOutFilter singleSignOutFilter = new SingleSignOutFilter();
		// 设置cas服务端路径前缀，应用于front channel的注销请求
		singleSignOutFilter.setCasServerUrlPrefix(casConfig.getCasUrl());
		singleSignOutFilter.setIgnoreInitConfiguration(true);
		return singleSignOutFilter;
	}

	/**
	 * 
	 * @描述：登录退出Filter类，转发至cas服务端进行注销
	 *
	 * @返回：LogoutFilter
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午3:10:57
	 */
	@Bean
	public LogoutFilter casLogoutFilter() {
		// 设置回调地址，以免注销后页面不再跳转
		LogoutFilter logoutFilter = new LogoutFilter(casConfig.getCasLogoutUrl(), new SecurityContextLogoutHandler());
		logoutFilter.setFilterProcessesUrl(casConfig.getAppLogoutUrl());
		return logoutFilter;
	}

	/**
	 * 
	 * @描述：cas校验Filter处理类，包括对含有token的请求或者指定的路径请求处理
	 *
	 * @返回：CasAuthenticationFilter
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午3:14:48
	 */
	@Bean
	public CasAuthenticationFilter casAuthenticationFilter() throws Exception {
		CasAuthenticationFilter casAuthenticationFilter = new CasAuthenticationFilter();
		casAuthenticationFilter.setAuthenticationManager(authenticationManager());
		casAuthenticationFilter.setFilterProcessesUrl(casConfig.getAppLoginUrl());
		return casAuthenticationFilter;
	}

	/**
	 * 
	 * @描述：CAS认证 Provider
	 *
	 * @返回：CasAuthenticationProvider
	 *
	 * @作者：zhongjy
	 *
	 * @时间：2017年10月14日 下午12:41:04
	 */
	@Bean
	public CasAuthenticationProvider casAuthenticationProvider() {
		CasAuthenticationProvider casAuthenticationProvider = new CasAuthenticationProvider();
		casAuthenticationProvider.setAuthenticationUserDetailsService(customUserDetailsService);
		//casAuthenticationProvider.setUserDetailsService(customUserDetailsService); // 这里只是接口类型，实现的接口不一样，都可以的。
		casAuthenticationProvider.setServiceProperties(serviceProperties());
		casAuthenticationProvider.setTicketValidator(cas20ServiceTicketValidator());
		casAuthenticationProvider.setKey("casAuthenticationProviderKey");
		return casAuthenticationProvider;
	}

}
